# Push_swap

*This project has been created as part of the 42 curriculum by jmattion, kkraft.*

## Description

The **Push_swap** project is a straightforward yet complex algorithmic challenge: data must be sorted. We have at our disposal a set of integer values, two stacks (`a` and `b`), and a limited set of instructions to manipulate them.

The main goal is to write a C program called `push_swap` which calculates and displays on the standard output the smallest program, made of Push\_swap language instructions, that sorts the integers received as arguments.

To succeed, we had to manipulate various types of algorithms and choose the most appropriate solution for optimized data sorting, focusing on algorithmic complexity. This project implements four distinct sorting strategies:

1.  **Simple Algorithm O(n^2):** A baseline algorithm for small inputs.
2.  **Medium Algorithm O(n sqrt{n}):** A chunk-based approach.
3.  **Complex Algorithm O(n log n):** A highly optimized strategy for large datasets.
4.  **Adaptive Algorithm:** A smart selector that chooses the best strategy based on the "disorder" metric of the input stack.

Additionally, a custom **benchmark mode** have been implemented to verify the sorting validity and measure performance.

## Instructions

### Compilation

Use the provided `Makefile` to compile the project.

  * **Compile the main program:**

    ```bash
    make
    ```

  * **Compile the bonus (checker):**

    ```bash
    make bonus
    ```

  * **Clean up:**

    ```bash
    make clean      # Removes object files
    make fclean     # Removes object files and executables
    make re         # Recompiles everything
    ```

### Execution

#### The `push_swap` program

Run the program with a list of integers as arguments:

```bash
./push_swap 2 1 3 6 5 8
```
or

```bash
./push_swap "2 1 3 6 5 8"
```

You can use specific flags to force a sorting strategy or enable benchmark mode:

  * `--simple`: Forces the $O(n^2)$ algorithm.
  * `--medium`: Forces the $O(n\sqrt{n})$ algorithm.
  * `--complex`: Forces the $O(n \log n)$ algorithm.
  * `--adaptive`: (Default) Selects the strategy based on disorder.
  * `--bench`: Displays performance statistics (operation counts, disorder percentage) on `stderr` after sorting.

**Example with benchmark:**

```bash
./push_swap --bench 4 67 3 87 23
```

#### The `checker` program (Bonus)

The checker verifies if the list of instructions generated by `push_swap` actually sorts the stack.

```bash
ARG="4 67 3 87 23"; ./push_swap $ARG | ./checker $ARG
```

  * Displays `OK` if the stack is sorted and stack `b` is empty.
  * Displays `KO` otherwise.
  * Displays `Error` in case of invalid inputs.

## Algorithms

### Selection Sort (Simple) $O(n^2)$
#### 1 - Miniimum Search

In each iteration, the algorithm locates the position of the smallest unsorted element, identified by its lowest sorted index (or raw value), within stack a.

#### 2 - Rotation to the Top

A distance calculation is performed to determine the shortest operation sequence (minimum of ra or rra) required to bring this minimum element to the top of stack a.

#### 3 - Unidirectional Transfer

The element is immediately transferred to stack b using the pb instruction.

#### 4 - Reconstruction Phase

Steps 1 through 3 are repeated until a is completely empty. Stack b then holds all elements in strictly descending order (from largest to smallest, with the absolute minimum at the bottom).

#### 5 - Finalization: 

To meet the sorting condition (elements in ascending order in a and empty b), all elements are returned from b to a using a sequence of pa operations.

### Chunk Sort (Medium) $O(n\sqrt{n})$

### Turk Sort (Complex) $O(n \log n)$

### Adaptive Strategy

## Resources