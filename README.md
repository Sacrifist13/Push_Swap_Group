# Push_swap

*This project has been created as part of the 42 curriculum by jmattion, kkraft.*

## Description

The **Push_swap** project is a straightforward yet complex algorithmic challenge: data must be sorted. We have at our disposal a set of integer values, two stacks (`a` and `b`), and a limited set of instructions to manipulate them.

The main goal is to write a C program called `push_swap` which calculates and displays on the standard output the smallest program, made of Push\_swap language instructions, that sorts the integers received as arguments.

To succeed, we had to manipulate various types of algorithms and choose the most appropriate solution for optimized data sorting, focusing on algorithmic complexity. This project implements four distinct sorting strategies:

1.  **Simple Algorithm O(n^2):** A baseline algorithm for small inputs.
2.  **Medium Algorithm O(n sqrt{n}):** A chunk-based approach.
3.  **Complex Algorithm O(n log n):** A highly optimized strategy for large datasets.
4.  **Adaptive Algorithm:** A smart selector that chooses the best strategy based on the "disorder" metric of the input stack.

Additionally, a custom **benchmark mode** have been implemented to verify the sorting validity and measure performance.

## Instructions

### Compilation

Use the provided `Makefile` to compile the project.

  * **Compile the main program:**

    ```bash
    make
    ```

  * **Compile the bonus (checker):**

    ```bash
    make bonus
    ```

  * **Clean up:**

    ```bash
    make clean      # Removes object files
    make fclean     # Removes object files and executables
    make re         # Recompiles everything
    ```

### Execution

#### The `push_swap` program

Run the program with a list of integers as arguments:

```bash
./push_swap 2 1 3 6 5 8
```
or

```bash
./push_swap "2 1 3 6 5 8"
```

You can use specific flags to force a sorting strategy or enable benchmark mode:

  * `--simple`: Forces the $O(n^2)$ algorithm.
  * `--medium`: Forces the $O(n\sqrt{n})$ algorithm.
  * `--complex`: Forces the $O(n \log n)$ algorithm.
  * `--adaptive`: (Default) Selects the strategy based on disorder.
  * `--bench`: Displays performance statistics (operation counts, disorder percentage) on `stderr` after sorting.

**Example with benchmark:**

```bash
./push_swap --bench 4 67 3 87 23
```

#### The `checker` program (Bonus)

The checker verifies if the list of instructions generated by `push_swap` actually sorts the stack.

```bash
ARG="4 67 3 87 23"; ./push_swap $ARG | ./checker $ARG
```

  * Displays `OK` if the stack is sorted and stack `b` is empty.
  * Displays `KO` otherwise.
  * Displays `Error` in case of invalid inputs.

## Algorithms

### Selection Sort (Simple) $O(n^2)$
* **1 - Miniimum Search**

In each iteration, the algorithm locates the position of the smallest unsorted element, identified by its lowest sorted index (or raw value), within stack `a`.

* **2 - Rotation to the Top**

A distance calculation is performed to determine the shortest operation sequence (minimum of `ra` or `rra`) required to bring this minimum element to the top of stack `a`.

* **3 - Unidirectional Transfer**

The element is immediately transferred to stack `b` using the `pb` instruction.

* **4 - Reconstruction Phase**

Steps 1 through 3 are repeated until a is completely empty. Stack `b` then holds all elements in strictly descending order (from largest to smallest, with the absolute minimum at the bottom).

* **5 - Finalization** 

To meet the sorting condition (elements in ascending order in a and empty `b`), all elements are returned from `b` to `a` using a sequence of `pa` operations.

### Chunk Sort (Medium) $O(n\sqrt{n})$
#### Phase 1 - Emptying A (A -> B)
* **1 - Dynamic Chunk Sizing**

The algorithm calculates an optimal chunk size based on the square root of the total number of elements in stack `a`. This divides the stack into dynamic ranges.

* **2 - Range-Based Distribution**

The algorithm iterates through stack `a`, identifying elements that fall within the current chunk limit (or the next chunk for optimization). If an element belongs to the current range, it is immediately pushed to stack `b` using `pb`.

* **3 - Smart Placement in B**

As elements are pushed to `b`, a local optimization is applied:
- If the element belongs to the lower half of the current chunk, stack `b` is rotated (`rb`). This places smaller elements at the bottom, keeping larger elements of the chunk near the top.
- If the element belongs to the upper half, it remains at the top of `b`.

* **4 - Variable Increment**

This cycle repeats, increasing the range limit by the chunk size, until all elements from `a` have been transferred to `b`.

#### Phase 2 - Final triage and filling A (B -> A)
* **5 - Greedy Sort (Max to Top)**

To reconstruct `a` in sorted order, the algorithm locates the maximum value within stack `b`. It calculates the most efficient rotation direction (up via `rb` or down via `rrb`) to bring this maximum element to the top, then pushes it back to `a` (`pa`). This repeats until `b` is empty.

### Segment Logic Sort (Complex) $O(n \log n)$
#### Phase 1 - Distribution and Pre-Sorting (A -> B)

This phase moves the majority of elements from stack `a` to stack `b`, performing a binary pre-sorting within `b` while minimizing rotations in `a`.

* **1 - Chunk Division**
Stack `a` is conceptually divided into 8 equal segments (chunks) based on the sorted indices.

* **2 - Iterative Block Processing (2 Chunks at a Time)**
The algorithm processes the unsorted elements by defining a current processing range covering two consecutive chunks (e.g., Chunk 1 & 2, then Chunk 3 & 4).

* **3 - Targeting and Binary Pre-sorting in B**
As elements within the current two-chunk range are pushed to B, their placement is optimized for Phase 4:

 - Upper Placement (Largest Index): If an element belongs to the upper chunk of the pair, it is pushed to `b` and kept near the top (using pb).
 - Lower Placement (Smallest Index): If an element belongs to the lower chunk of the pair, it is pushed to `b` and immediately rotated towards the bottom (`rb`).
 - Optimization: If the current element belongs to the Lower Chunk and the next targeted element in `a` is not yet at the top of `a`, the instruction `rr` is used instead of separate `ra` and `rb` operations.

Termination Condition This entire process (Steps 2 and 3) is repeated iteratively until stack `a` is completely empty.

#### Phase 2 - Final Triage and Minimum Cost Analysis (B -> A)
* **1 - Chunk Priority**
The process is executed chunk by chunk, starting with the elements belonging to the largest index chunk (highest values) present in `b`, and then progressively moving down to the smallest index chunk. This ensures `a` is built correctly from the largest numbers downwards.

* **2 - Target Calculation**
Within the currently active chunk, the algorithm performs its cost analysis:
 - For every element in `b` belonging to this chunk, the algorithm identifies the ideal insertion point in `a`
 - The algorithm calculates the total cost (the number of operations) required to move the element from its current position in `b` to its
    target position in `a`. This cost includes:
     - Rotations required in `b` (`rb` or `rrb`).
     - Rotations required in `a` (`ra` or `rra`).
     - Optimization for combined rotations (`rr` or `rrr`) when possible.

* **3 - Execution**
The algorithm executes the single set of instructions corresponding to the element with the absolute minimum cost across the elements of the current chunk in stack `b`.

* **4 - Iteration**
This process (Steps 2, 3) is repeated until the current chunk is empty in `b`, at which point the algorithm moves to the next largest index chunk, and so on, until `b` is empty.

* **5 - Final Rotation**
Once `b` is empty, stack `a` is sorted except for potentially needing a final minimal rotation (`ra` or `rra`) to bring the smallest element (index 0) to the very top.

### Adaptive Strategy

## Resources